import{importShared as $t,__tla as vt}from"./__federation_fn_import-9636f06d.js";import{ah as U,aj as V,ba as X,bm as q,bh as z,x as B,bf as E,bd as I,br as mt,aX as jt,bk as gt,bb as Ot,bi as Pt,n as St,bs as At,_ as wt}from"./runtime-core.esm-bundler-470d2954.js";let g,D,K,L,Q,Y,Z,tt,R,et,nt,y,it,at,st,xt=Promise.all([(()=>{try{return vt}catch{}})()]).then(async()=>{await $t("vue");var rt=!1;let k,O;y=t=>k=t,Y=()=>U()&&V(O)||k,O=Symbol();function M(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(g||(g={}));const ot=typeof window<"u";L=function(){const t=X(!0),i=t.run(()=>q({}));let n=[],e=[];const a=z({install(o){y(a),a._a=o,o.provide(O,a),o.config.globalProperties.$pinia=a,e.forEach(u=>n.push(u)),e=[]},use(o){return!this._a&&!rt?e.push(o):n.push(o),this},_p:n,_a:null,_e:t,_s:new Map,state:i});return a},K=function(t,i){return()=>{}};const F=()=>{};function H(t,i,n,e=F){t.push(i);const a=()=>{const o=t.indexOf(i);o>-1&&(t.splice(o,1),e())};return!n&&Ot()&&Pt(a),a}function b(t,...i){t.slice().forEach(n=>{n(...i)})}const ct=t=>t();function C(t,i){t instanceof Map&&i instanceof Map&&i.forEach((n,e)=>t.set(e,n)),t instanceof Set&&i instanceof Set&&i.forEach(t.add,t);for(const n in i){if(!i.hasOwnProperty(n))continue;const e=i[n],a=t[n];M(a)&&M(e)&&t.hasOwnProperty(n)&&!E(e)&&!I(e)?t[n]=C(a,e):t[n]=e}return t}const T=Symbol();at=function(t){return Object.defineProperty(t,T,{})};function ut(t){return!M(t)||!t.hasOwnProperty(T)}const{assign:l}=Object;function pt(t){return!!(E(t)&&t.effect)}function ft(t,i,n,e){const{state:a,actions:o,getters:u}=i,c=n.state.value[t];let P;function d(){c||(n.state.value[t]=a?a():{});const _=At(n.state.value[t]);return l(_,o,Object.keys(u||{}).reduce(($,v)=>($[v]=z(wt(()=>{y(n);const m=n._s.get(t);return u[v].call(m,m)})),$),{}))}return P=W(t,d,i,n,e,!0),P}function W(t,i,n={},e,a,o){let u;const c=l({actions:{}},n),P={deep:!0};let d,_,$=[],v=[],m;const j=e.state.value[t];!o&&!j&&(e.state.value[t]={}),q({});let J;function N(r){let s;d=_=!1,typeof r=="function"?(r(e.state.value[t]),s={type:g.patchFunction,storeId:t,events:m}):(C(e.state.value[t],r),s={type:g.patchObject,payload:r,storeId:t,events:m});const h=J=Symbol();St().then(()=>{J===h&&(d=!0)}),_=!0,b($,s,e.state.value[t])}const ht=o?function(){const{state:r}=n,s=r?r():{};this.$patch(h=>{l(h,s)})}:F;function lt(){u.stop(),$=[],v=[],e._s.delete(t)}function dt(r,s){return function(){y(e);const h=Array.from(arguments),A=[],w=[];function bt(p){A.push(p)}function _t(p){w.push(p)}b(v,{args:h,name:r,store:f,after:bt,onError:_t});let x;try{x=s.apply(this&&this.$id===t?this:f,h)}catch(p){throw b(w,p),p}return x instanceof Promise?x.then(p=>(b(A,p),p)).catch(p=>(b(w,p),Promise.reject(p))):(b(A,x),x)}}const yt={_p:e,$id:t,$onAction:H.bind(null,v),$patch:N,$reset:ht,$subscribe(r,s={}){const h=H($,r,s.detached,()=>A()),A=u.run(()=>jt(()=>e.state.value[t],w=>{(s.flush==="sync"?_:d)&&r({storeId:t,type:g.direct,events:m},w)},l({},P,s)));return h},$dispose:lt},f=gt(yt);e._s.set(t,f);const S=(e._a&&e._a.runWithContext||ct)(()=>e._e.run(()=>(u=X()).run(i)));for(const r in S){const s=S[r];if(E(s)&&!pt(s)||I(s))o||(j&&ut(s)&&(E(s)?s.value=j[r]:C(s,j[r])),e.state.value[t][r]=s);else if(typeof s=="function"){const h=dt(r,s);S[r]=h,c.actions[r]=s}}return l(f,S),l(B(f),S),Object.defineProperty(f,"$state",{get:()=>e.state.value[t],set:r=>{N(s=>{l(s,r)})}}),e._p.forEach(r=>{l(f,u.run(()=>r({store:f,app:e._a,pinia:e,options:c})))}),j&&o&&n.hydrate&&n.hydrate(f.$state,j),d=!0,_=!0,f}Q=function(t,i,n){let e,a;const o=typeof i=="function";typeof t=="string"?(e=t,a=o?n:i):(a=t,e=t.id);function u(c,P){const d=U();return c=c||(d?V(O,null):null),c&&y(c),c=k,c._s.has(e)||(o?W(e,i,a,c):ft(e,a,c)),c._s.get(e)}return u.$id=e,u};let G="Store";it=function(t){G=t},et=function(...t){return t.reduce((i,n)=>(i[n.$id+G]=function(){return n(this.$pinia)},i),{})},R=function(t,i){return Array.isArray(i)?i.reduce((n,e)=>(n[e]=function(){return t(this.$pinia)[e]},n),{}):Object.keys(i).reduce((n,e)=>(n[e]=function(){const a=t(this.$pinia),o=i[e];return typeof o=="function"?o.call(this,a):a[o]},n),{})},tt=R,Z=function(t,i){return Array.isArray(i)?i.reduce((n,e)=>(n[e]=function(...a){return t(this.$pinia)[e](...a)},n),{}):Object.keys(i).reduce((n,e)=>(n[e]=function(...a){return t(this.$pinia)[i[e]](...a)},n),{})},nt=function(t,i){return Array.isArray(i)?i.reduce((n,e)=>(n[e]={get(){return t(this.$pinia)[e]},set(a){return t(this.$pinia)[e]=a}},n),{}):Object.keys(i).reduce((n,e)=>(n[e]={get(){return t(this.$pinia)[i[e]]},set(a){return t(this.$pinia)[i[e]]=a}},n),{})},st=function(t){{t=B(t);const i={};for(const n in t){const e=t[n];(E(e)||I(e))&&(i[n]=mt(t,n))}return i}},D=function(t){t.mixin({beforeCreate(){const i=this.$options;if(i.pinia){const n=i.pinia;if(!this._provided){const e={};Object.defineProperty(this,"_provided",{get:()=>e,set:a=>Object.assign(e,a)})}this._provided[O]=n,this.$pinia||(this.$pinia=n),n._a=this,ot&&y(n)}else!this.$pinia&&i.parent&&i.parent.$pinia&&(this.$pinia=i.parent.$pinia)},destroyed(){delete this._pStores}})}});export{g as MutationType,D as PiniaVuePlugin,xt as __tla,K as acceptHMRUpdate,L as createPinia,Q as defineStore,Y as getActivePinia,Z as mapActions,tt as mapGetters,R as mapState,et as mapStores,nt as mapWritableState,y as setActivePinia,it as setMapStoreSuffix,at as skipHydrate,st as storeToRefs};
